<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VO3 Script Chunker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }
        
        @media (max-width: 968px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            display: flex;
            flex-direction: column;
        }
        
        .panel h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 0.95em;
        }
        
        .control-group input[type="number"],
        .control-group input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-container input[type="range"] {
            flex: 1;
        }
        
        .slider-value {
            background: #667eea;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 600;
            min-width: 45px;
            text-align: center;
        }
        
        textarea {
            width: 100%;
            min-height: 400px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .button:active {
            transform: translateY(0);
        }
        
        .output {
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            min-height: 400px;
            overflow-y: auto;
            max-height: 600px;
        }
        
        .take {
            background: white;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .take-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .take-number {
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.9em;
        }
        
        .take-duration {
            color: #666;
            font-size: 0.9em;
        }
        
        .take-content {
            line-height: 1.8;
            font-size: 1.05em;
        }
        
        .filler {
            background: #ffe5e5;
            padding: 2px 6px;
            border-radius: 4px;
            color: #cc0000;
            font-style: italic;
            text-decoration: line-through;
        }
        
        .overlap {
            background: #fff4e5;
            padding: 2px 6px;
            border-radius: 4px;
            color: #ff8800;
        }
        
        .main-content {
            background: #e5f4e5;
            padding: 2px 6px;
            border-radius: 4px;
            color: #006600;
            font-weight: 500;
        }
        
        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }
        
        .legend-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .copy-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: background 0.2s;
            margin-left: 8px;
        }
        
        .copy-button:hover {
            background: #218838;
        }
        
        .generate-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.2s;
            margin-left: 8px;
        }
        
        .generate-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .generate-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .generating {
            background: #ffa500 !important;
        }
        
        .generation-status {
            margin-top: 8px;
            font-size: 0.85em;
            padding: 8px;
            border-radius: 4px;
            display: none;
        }
        
        .status-pending {
            background: #fff4e5;
            color: #ff8800;
            border: 1px solid #ff8800;
        }
        
        .status-success {
            background: #e5f4e5;
            color: #006600;
            border: 1px solid #28a745;
        }
        
        .status-error {
            background: #ffe5e5;
            color: #cc0000;
            border: 1px solid #ff4444;
        }
        
        .empty-state {
            text-align: center;
            color: #999;
            padding: 60px 20px;
        }
        
        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéôÔ∏è VO3 Script Chunker</h1>
            <p>Break down your scripts into perfect 8-second VO3 chunks with smart overlap</p>
        </div>
        
        <div class="content">
            <div class="panel">
                <h2>üìù Input Script</h2>
                
                <div class="controls">
                    <div class="control-group" style="background: #fff; padding: 15px; border-radius: 8px; border: 2px solid #667eea;">
                        <label style="color: #667eea; font-weight: 700;">üîë Gemini API Key (for VO3 generation)</label>
                        <input type="password" id="apiKey" placeholder="Enter your Gemini API key from ai.google.dev" style="margin-bottom: 8px;">
                        <div style="font-size: 0.85em; color: #666;">
                            Don't have a key? <a href="https://ai.google.dev/" target="_blank" style="color: #667eea;">Get one here</a> ‚Ä¢ Your key is stored locally and never sent anywhere except Google's API
                        </div>
                    </div>
                    
                    <div class="control-group" style="background: #fff; padding: 15px; border-radius: 8px; border: 2px solid #667eea;">
                        <label style="color: #667eea; font-weight: 700;">üé¨ VO3 Visual Prompt (scene description, style, camera)</label>
                        <textarea id="vo3Prompt" placeholder="Example: A professional woman in scrubs sitting at a kitchen table, warm lighting, cinematic shot, documentary style, close-up on face" style="width: 100%; min-height: 80px; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 0.95em; resize: vertical;"></textarea>
                        <div style="font-size: 0.85em; color: #666; margin-top: 8px;">
                            This visual prompt will be combined with each take's text as: <strong>[Your prompt] ; spoken text: "[take text]"</strong>
                        </div>
                    </div>
                    
                    <div class="control-group" style="background: #fff; padding: 15px; border-radius: 8px; border: 2px solid #667eea;">
                        <label style="color: #667eea; font-weight: 700;">üñºÔ∏è Starting Frame Image (optional)</label>
                        <input type="file" id="imageUpload" accept="image/*" style="margin-bottom: 8px;">
                        <div id="imagePreview" style="margin-top: 10px; display: none;">
                            <img id="previewImg" style="max-width: 100%; max-height: 150px; border-radius: 8px; border: 2px solid #ddd;">
                            <button onclick="clearImage()" style="margin-top: 8px; padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em;">Remove Image</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Target Script Duration (seconds)</label>
                        <div class="slider-container">
                            <input type="range" id="scriptDuration" min="15" max="120" step="5" value="45">
                            <span class="slider-value" id="scriptDurationValue">45s</span>
                        </div>
                    </div>
                    
                    <div id="durationWarning" style="padding: 12px; border-radius: 8px; margin-bottom: 15px; display: none; font-weight: 600; font-size: 0.95em;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span id="warningIcon"></span>
                            <span id="warningText"></span>
                        </div>
                        <div style="margin-top: 8px; background: rgba(255,255,255,0.3); border-radius: 4px; height: 8px; overflow: hidden;">
                            <div id="progressBar" style="height: 100%; transition: width 0.3s, background 0.3s;"></div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Target Duration per Take (seconds)</label>
                        <div class="slider-container">
                            <input type="range" id="duration" min="5" max="9" step="0.5" value="7">
                            <span class="slider-value" id="durationValue">7s</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Overlap Duration (seconds)</label>
                        <div class="slider-container">
                            <input type="range" id="overlap" min="1" max="4" step="0.5" value="2">
                            <span class="slider-value" id="overlapValue">2s</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Filler Prefix (optional - will be cut in editing)</label>
                        <input type="text" id="filler" placeholder="e.g., So anyway, or Like I was saying," value="So anyway,">
                        <div style="margin-top: 10px;">
                            <label style="display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer;">
                                <input type="checkbox" id="fillerAllTakes" style="width: auto; cursor: pointer;">
                                <span>Add filler prefix to all takes (not just the first one)</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <textarea id="scriptInput" placeholder="Paste your script here...">After 12-hour shifts caring for everyone else's kids, I come home completely tapped out for my own family.
The stuff I see at work follows me home. I can't shut my brain off. I'm always on edge, even when I'm supposed to be relaxing. My kids deserve a mom who's actually present, not just going through the motions.
But then I found Dr. Cianna's Conscious Collective. It's course and community all about being grounded and resilient so you can bounce back from stress. 
Healthcare burnout is real and you can get help for only $7. 
It's not just training videos - it's an actual community of women who understand. There's real people supporting each other, helping to use simple breath work, movement and meditation to help calm your nervous system so you can be at your best. .
The exercises literally takes like  5 minutes and can be done before work or even on quick breaks. 
If you're thinking 'I should be stronger' - girl, we all need help sometimes. Check the link below.</textarea>
                
                <button class="button" onclick="processScript()">Generate VO3 Takes ‚ú®</button>
            </div>
            
            <div class="panel">
                <h2>üé¨ VO3 Takes</h2>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-box" style="background: #ffe5e5;"></div>
                        <span><strong>Filler</strong> - Cut in edit</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box" style="background: #fff4e5;"></div>
                        <span><strong>Overlap</strong> - For smooth transitions</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box" style="background: #e5f4e5;"></div>
                        <span><strong>Main</strong> - Keep this content</span>
                    </div>
                </div>
                
                <div class="output" id="output">
                    <div class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                        </svg>
                        <p>Your VO3 takes will appear here</p>
                    </div>
                </div>
                
                <div id="exportSection" style="display: none; margin-top: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="color: #333; font-size: 1.2em; margin: 0;">üìã Copy/Paste Format</h3>
                        <button class="copy-button" onclick="copyAllTakes()" style="padding: 10px 20px; font-size: 1em;">Copy All Takes</button>
                    </div>
                    <textarea id="exportText" readonly style="width: 100%; min-height: 300px; padding: 15px; border: 2px solid #ddd; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.95em; background: #f8f9fa; resize: vertical;"></textarea>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Update slider values display
        document.getElementById('duration').addEventListener('input', function() {
            document.getElementById('durationValue').textContent = this.value + 's';
        });
        
        document.getElementById('overlap').addEventListener('input', function() {
            document.getElementById('overlapValue').textContent = this.value + 's';
        });
        
        document.getElementById('scriptDuration').addEventListener('input', function() {
            document.getElementById('scriptDurationValue').textContent = this.value + 's';
            updateDurationWarning();
        });
        
        // Live update duration warning as user types
        document.getElementById('scriptInput').addEventListener('input', function() {
            updateDurationWarning();
        });
        
        // Image upload handling
        let uploadedImageBase64 = null;
        
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    uploadedImageBase64 = event.target.result;
                    document.getElementById('previewImg').src = uploadedImageBase64;
                    document.getElementById('imagePreview').style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        });
        
        function clearImage() {
            uploadedImageBase64 = null;
            document.getElementById('imageUpload').value = '';
            document.getElementById('imagePreview').style.display = 'none';
        }
        
        // API key storage (in localStorage)
        document.getElementById('apiKey').addEventListener('change', function() {
            if (this.value) {
                localStorage.setItem('gemini_api_key', this.value);
            }
        });
        
        // Load saved API key on page load
        window.addEventListener('load', function() {
            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
            }
        });
        
        function updateDurationWarning() {
            const script = document.getElementById('scriptInput').value.trim();
            const targetDuration = parseFloat(document.getElementById('scriptDuration').value);
            const warningDiv = document.getElementById('durationWarning');
            const warningIcon = document.getElementById('warningIcon');
            const warningText = document.getElementById('warningText');
            const progressBar = document.getElementById('progressBar');
            
            if (!script) {
                warningDiv.style.display = 'none';
                return;
            }
            
            const estimatedDuration = estimateDuration(script);
            const percentage = (estimatedDuration / targetDuration) * 100;
            
            warningDiv.style.display = 'block';
            progressBar.style.width = Math.min(percentage, 100) + '%';
            
            if (estimatedDuration > targetDuration) {
                const overBy = (estimatedDuration - targetDuration).toFixed(1);
                warningDiv.style.background = '#ffe5e5';
                warningDiv.style.border = '2px solid #ff4444';
                warningDiv.style.color = '#cc0000';
                warningIcon.textContent = '‚ö†Ô∏è';
                warningText.textContent = `Script is ~${estimatedDuration.toFixed(1)}s (${overBy}s over ${targetDuration}s target)`;
                progressBar.style.background = '#ff4444';
            } else {
                const underBy = (targetDuration - estimatedDuration).toFixed(1);
                warningDiv.style.background = '#e5f4e5';
                warningDiv.style.border = '2px solid #28a745';
                warningDiv.style.color = '#006600';
                warningIcon.textContent = '‚úì';
                warningText.textContent = `Script is ~${estimatedDuration.toFixed(1)}s (${underBy}s under ${targetDuration}s target)`;
                progressBar.style.background = '#28a745';
            }
        }
        
        function estimateDuration(text) {
            // Average speaking rate: ~150 words per minute = 2.5 words per second
            const words = text.trim().split(/\s+/).length;
            return words / 2.5;
        }
        
        function splitIntoSentences(text) {
            // Split on sentence boundaries but keep the punctuation
            return text.match(/[^.!?]+[.!?]+/g) || [text];
        }
        
        function processScript() {
            const script = document.getElementById('scriptInput').value.trim();
            const targetDuration = parseFloat(document.getElementById('duration').value);
            const overlapDuration = parseFloat(document.getElementById('overlap').value);
            const fillerPrefix = document.getElementById('filler').value.trim();
            
            if (!script) {
                document.getElementById('output').innerHTML = `
                    <div class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                        </svg>
                        <p>Please paste a script first</p>
                    </div>
                `;
                return;
            }
            
            // Split script into sentences
            const sentences = splitIntoSentences(script);
            const takes = [];
            const minDuration = targetDuration - 1.5; // Acceptable range: target ¬± 1.5s
            const maxDuration = targetDuration + 1.5;
            
            let i = 0;
            while (i < sentences.length) {
                const sentence = sentences[i].trim();
                const sentenceDuration = estimateDuration(sentence);
                
                // If this sentence alone is in acceptable range, use it as-is (no overlap)
                if (sentenceDuration >= minDuration && sentenceDuration <= maxDuration) {
                    takes.push({
                        text: sentence,
                        duration: sentenceDuration,
                        overlap: null, // No overlap needed
                        previousOverlap: null,
                        needsOverlap: false
                    });
                    i++;
                }
                // If sentence is too short, try combining with next sentence(s)
                else if (sentenceDuration < minDuration) {
                    let combinedText = sentence;
                    let combinedDuration = sentenceDuration;
                    let endIndex = i;
                    
                    // Keep adding sentences until we hit a good duration
                    while (endIndex + 1 < sentences.length && combinedDuration < minDuration) {
                        endIndex++;
                        const nextSentence = sentences[endIndex].trim();
                        const nextDuration = estimateDuration(nextSentence);
                        
                        // Check if adding full sentence would be too much
                        if (combinedDuration + nextDuration > maxDuration) {
                            // Add only part of the next sentence
                            const words = nextSentence.split(/\s+/);
                            const wordsNeeded = Math.ceil((targetDuration - combinedDuration) * 2.5);
                            const partialText = words.slice(0, wordsNeeded).join(' ');
                            
                            // Create overlap zone
                            const overlapWords = Math.ceil(overlapDuration * 2.5);
                            const overlapText = words.slice(0, overlapWords).join(' ');
                            
                            takes.push({
                                text: combinedText + ' ' + partialText,
                                duration: estimateDuration(combinedText + ' ' + partialText),
                                overlap: overlapText,
                                previousOverlap: null,
                                needsOverlap: true
                            });
                            
                            // Next take starts with the overlap
                            i = endIndex;
                            break;
                        } else {
                            // Add the full sentence
                            combinedText += ' ' + nextSentence;
                            combinedDuration += nextDuration;
                            
                            // If we're now in good range, save it
                            if (combinedDuration >= minDuration) {
                                takes.push({
                                    text: combinedText,
                                    duration: combinedDuration,
                                    overlap: null,
                                    previousOverlap: null,
                                    needsOverlap: false
                                });
                                i = endIndex + 1;
                                break;
                            }
                        }
                    }
                    
                    // If we've reached the end, add what we have
                    if (endIndex === sentences.length - 1 && i <= endIndex) {
                        takes.push({
                            text: combinedText,
                            duration: combinedDuration,
                            overlap: null,
                            previousOverlap: null,
                            needsOverlap: false
                        });
                        i = endIndex + 1;
                    }
                }
                // If sentence is too long, we need to split it
                else {
                    const words = sentence.split(/\s+/);
                    const targetWords = Math.ceil(targetDuration * 2.5);
                    const chunk = words.slice(0, targetWords).join(' ');
                    
                    // Create overlap
                    const overlapWords = Math.ceil(overlapDuration * 2.5);
                    const overlapText = words.slice(0, overlapWords).join(' ');
                    
                    takes.push({
                        text: chunk,
                        duration: estimateDuration(chunk),
                        overlap: overlapText,
                        previousOverlap: null,
                        needsOverlap: true
                    });
                    
                    // Put the rest back as a new sentence for next iteration
                    const remainder = words.slice(targetWords).join(' ');
                    sentences[i] = remainder;
                    // Don't increment i, process the remainder next
                }
            }
            
            // Now process overlaps between takes
            for (let j = 1; j < takes.length; j++) {
                const prevTake = takes[j - 1];
                if (prevTake.needsOverlap && prevTake.overlap) {
                    takes[j].previousOverlap = prevTake.overlap;
                }
            }
            
            // Render takes
            renderTakes(takes, fillerPrefix);
        }
        
        function renderTakes(takes, fillerPrefix) {
            const output = document.getElementById('output');
            const exportSection = document.getElementById('exportSection');
            const exportText = document.getElementById('exportText');
            const fillerAllTakes = document.getElementById('fillerAllTakes').checked;
            
            if (takes.length === 0) {
                output.innerHTML = `
                    <div class="empty-state">
                        <p>No takes generated</p>
                    </div>
                `;
                exportSection.style.display = 'none';
                return;
            }
            
            let html = '';
            let exportContent = '';
            
            takes.forEach((take, index) => {
                const takeNumber = index + 1;
                // Add filler to first take OR all takes if checkbox is checked
                const hasFillerPrefix = fillerPrefix && (index === 0 || fillerAllTakes);
                const hasPreviousOverlap = take.previousOverlap;
                const hasNextOverlap = take.needsOverlap && take.overlap;
                
                // Build the full take text for copying
                let fullText = '';
                if (hasFillerPrefix) {
                    fullText = fillerPrefix + ' ';
                }
                if (hasPreviousOverlap) {
                    fullText += take.previousOverlap + ' ';
                }
                fullText += take.text;
                
                // Build HTML with highlighting
                let contentHtml = '';
                if (hasFillerPrefix) {
                    contentHtml += `<span class="filler">${fillerPrefix}</span> `;
                }
                if (hasPreviousOverlap) {
                    contentHtml += `<span class="overlap">${take.previousOverlap}</span> `;
                }
                
                // Highlight the main content and overlap if exists
                if (hasNextOverlap) {
                    // Find where overlap starts in the text
                    const overlapStart = take.text.indexOf(take.overlap);
                    if (overlapStart === 0) {
                        // Overlap is at the beginning
                        const mainContent = take.text.substring(take.overlap.length);
                        contentHtml += `<span class="overlap">${take.overlap}</span> <span class="main-content">${mainContent}</span>`;
                    } else {
                        // Overlap is at the end
                        const mainContent = take.text.substring(0, take.text.lastIndexOf(take.overlap));
                        contentHtml += `<span class="main-content">${mainContent}</span> <span class="overlap">${take.overlap}</span>`;
                    }
                } else {
                    // No overlap, just main content
                    contentHtml += `<span class="main-content">${take.text}</span>`;
                }
                
                // Add note if no overlap needed
                let statusNote = '';
                if (!hasPreviousOverlap && !hasNextOverlap) {
                    statusNote = '<div style="margin-top: 10px; font-size: 0.85em; color: #28a745;">‚úì Complete sentence - no overlap needed</div>';
                }
                
                html += `
                    <div class="take">
                        <div class="take-header">
                            <span class="take-number">Take ${takeNumber}</span>
                            <div>
                                <span class="take-duration">~${take.duration.toFixed(1)}s</span>
                                <button class="copy-button" onclick="copyTake('${escapeHtml(fullText)}')">Copy</button>
                                <button class="generate-button" id="genBtn${takeNumber}" onclick="generateInVO3(${takeNumber}, '${escapeHtml(fullText)}')">
                                    üé¨ Generate in VO3
                                </button>
                            </div>
                        </div>
                        <div class="take-content">
                            ${contentHtml}
                        </div>
                        ${statusNote}
                        <div class="generation-status" id="status${takeNumber}"></div>
                    </div>
                `;
                
                // Build export text format
                exportContent += `TAKE ${takeNumber} (~${take.duration.toFixed(1)}s)\n`;
                if (hasFillerPrefix) {
                    exportContent += `[FILLER: ${fillerPrefix}] `;
                }
                if (hasPreviousOverlap) {
                    exportContent += `[OVERLAP: ${take.previousOverlap}] `;
                }
                exportContent += `${take.text}\n\n`;
            });
            
            output.innerHTML = html;
            exportText.value = exportContent;
            exportSection.style.display = 'block';
        }
        
        function escapeHtml(text) {
            return text.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }
        
        function copyTake(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Could add a toast notification here
                console.log('Copied to clipboard');
            });
        }
        
        function copyAllTakes() {
            const exportText = document.getElementById('exportText').value;
            navigator.clipboard.writeText(exportText).then(() => {
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úì Copied!';
                button.style.background = '#28a745';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            });
        }
        
        async function generateInVO3(takeNumber, prompt) {
            const apiKey = document.getElementById('apiKey').value;
            const vo3Prompt = document.getElementById('vo3Prompt').value.trim();
            const statusDiv = document.getElementById(`status${takeNumber}`);
            const button = document.getElementById(`genBtn${takeNumber}`);
            
            // Validation
            if (!apiKey) {
                statusDiv.innerHTML = '‚ö†Ô∏è Please enter your Gemini API key above';
                statusDiv.className = 'generation-status status-error';
                statusDiv.style.display = 'block';
                return;
            }
            
            if (!vo3Prompt) {
                statusDiv.innerHTML = '‚ö†Ô∏è Please enter a VO3 Visual Prompt above (scene description, style, camera)';
                statusDiv.className = 'generation-status status-error';
                statusDiv.style.display = 'block';
                return;
            }
            
            // Combine VO3 prompt with take text
            const fullPrompt = `${vo3Prompt} ; spoken text: "${prompt}"`;
            
            // Update UI to show generation in progress
            button.disabled = true;
            button.classList.add('generating');
            button.textContent = '‚è≥ Generating...';
            statusDiv.innerHTML = 'üé¨ Sending request to VO3...';
            statusDiv.className = 'generation-status status-pending';
            statusDiv.style.display = 'block';
            
            try {
                // Prepare the request payload
                const payload = {
                    model: 'veo-3-generate-preview',
                    contents: [{
                        parts: [{
                            text: fullPrompt
                        }]
                    }],
                    generationConfig: {
                        temperature: 1.0,
                        topP: 0.95,
                        topK: 40
                    }
                };
                
                // If there's an image, add it to the request
                if (uploadedImageBase64) {
                    const base64Data = uploadedImageBase64.split(',')[1];
                    const mimeType = uploadedImageBase64.split(',')[0].match(/:(.*?);/)[1];
                    
                    payload.contents[0].parts.unshift({
                        inlineData: {
                            mimeType: mimeType,
                            data: base64Data
                        }
                    });
                }
                
                // Make the API call
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/veo-3-generate-preview:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Check if we got an operation ID (video generation is async)
                if (data.name) {
                    // This is an operation - we need to poll for completion
                    statusDiv.innerHTML = '‚è≥ Video generation started... This may take 1-2 minutes';
                    await pollOperation(data.name, apiKey, takeNumber);
                } else if (data.candidates && data.candidates[0]) {
                    // Got immediate response
                    const videoUrl = extractVideoUrl(data);
                    if (videoUrl) {
                        statusDiv.innerHTML = `‚úÖ Generated! <a href="${videoUrl}" target="_blank" style="color: #667eea; font-weight: 600;">Download Video</a>`;
                        statusDiv.className = 'generation-status status-success';
                    } else {
                        statusDiv.innerHTML = '‚úÖ Generation complete! Check your Flow dashboard';
                        statusDiv.className = 'generation-status status-success';
                    }
                    button.textContent = '‚úì Generated';
                } else {
                    throw new Error('Unexpected response format from API');
                }
                
            } catch (error) {
                console.error('VO3 Generation Error:', error);
                statusDiv.innerHTML = `‚ùå Error: ${error.message}. <a href="https://ai.google.dev/" target="_blank" style="color: #667eea;">Check your API key</a>`;
                statusDiv.className = 'generation-status status-error';
                button.disabled = false;
                button.classList.remove('generating');
                button.textContent = 'üé¨ Generate in VO3';
            }
        }
        
        async function pollOperation(operationName, apiKey, takeNumber) {
            const statusDiv = document.getElementById(`status${takeNumber}`);
            const button = document.getElementById(`genBtn${takeNumber}`);
            const maxAttempts = 60; // 5 minutes max
            let attempts = 0;
            
            const poll = async () => {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/${operationName}?key=${apiKey}`);
                    const data = await response.json();
                    
                    if (data.done) {
                        if (data.error) {
                            throw new Error(data.error.message);
                        }
                        
                        const videoUrl = extractVideoUrl(data.response);
                        if (videoUrl) {
                            statusDiv.innerHTML = `‚úÖ Generated! <a href="${videoUrl}" target="_blank" style="color: #667eea; font-weight: 600;">Download Video</a>`;
                        } else {
                            statusDiv.innerHTML = '‚úÖ Generation complete! Check your Flow dashboard at labs.google.com/flow';
                        }
                        statusDiv.className = 'generation-status status-success';
                        button.textContent = '‚úì Generated';
                        button.classList.remove('generating');
                    } else {
                        attempts++;
                        if (attempts >= maxAttempts) {
                            throw new Error('Generation timed out. Check Flow dashboard.');
                        }
                        statusDiv.innerHTML = `‚è≥ Generating video... (${attempts * 5}s elapsed)`;
                        setTimeout(poll, 5000); // Poll every 5 seconds
                    }
                } catch (error) {
                    statusDiv.innerHTML = `‚ùå Error: ${error.message}`;
                    statusDiv.className = 'generation-status status-error';
                    button.disabled = false;
                    button.classList.remove('generating');
                    button.textContent = 'üé¨ Generate in VO3';
                }
            };
            
            await poll();
        }
        
        function extractVideoUrl(response) {
            // Try to extract video URL from various possible response structures
            if (response.candidates && response.candidates[0]) {
                const candidate = response.candidates[0];
                if (candidate.content && candidate.content.parts) {
                    for (const part of candidate.content.parts) {
                        if (part.fileData && part.fileData.fileUri) {
                            return part.fileData.fileUri;
                        }
                        if (part.videoMetadata && part.videoMetadata.uri) {
                            return part.videoMetadata.uri;
                        }
                    }
                }
            }
            return null;
        }
        
        // Auto-generate on page load
        window.addEventListener('load', function() {
            updateDurationWarning();
            processScript();
        });
    </script>
</body>
</html>