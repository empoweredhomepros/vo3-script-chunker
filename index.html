function processScript() {
    const script = document.getElementById('scriptInput').value.trim().replace(/-/g, '');
    const targetDuration = parseFloat(document.getElementById('duration').value);
    const overlapDuration = parseFloat(document.getElementById('overlap').value);
    const fillerPrefix = document.getElementById('filler').value.trim();
    
    if (!script) {
        document.getElementById('output').innerHTML = `
            <div class="empty-state">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
                <p>Please paste a script first</p>
            </div>
        `;
        return;
    }
    
    // Split script into sentences
    const sentences = splitIntoSentences(script);
    const takes = [];
    const minDuration = targetDuration - 1.5; // Acceptable range: target Â± 1.5s
    const maxDuration = targetDuration + 1.5;
    
    let i = 0;
    while (i < sentences.length) {
        const sentence = sentences[i].trim();
        const sentenceDuration = estimateDuration(sentence);
        
        // If this sentence alone is in acceptable range, use it as-is (no overlap)
        if (sentenceDuration >= minDuration && sentenceDuration <= maxDuration) {
            takes.push({
                text: sentence,
                duration: sentenceDuration,
                overlap: null, // No overlap needed
                previousOverlap: null,
                needsOverlap: false
            });
            i++;
        }
        // If sentence is too short, try combining with next sentence(s)
        else if (sentenceDuration < minDuration) {
            let combinedText = sentence;
            let combinedDuration = sentenceDuration;
            let endIndex = i;
            
            // Keep adding sentences until we hit a good duration
            while (endIndex + 1 < sentences.length && combinedDuration < minDuration) {
                endIndex++;
                const nextSentence = sentences[endIndex].trim();
                const nextDuration = estimateDuration(nextSentence);
                
                // Check if adding full sentence would be too much
                if (combinedDuration + nextDuration > maxDuration) {
                    // Add only part of the next sentence
                    const words = nextSentence.split(/\s+/);
                    const wordsNeeded = Math.ceil((targetDuration - combinedDuration) * 2.5);
                    const partialText = words.slice(0, wordsNeeded).join(' ');
                    
                    // Create overlap zone
                    const overlapWords = Math.ceil(overlapDuration * 2.5);
                    const overlapText = words.slice(0, overlapWords).join(' ');
                    
                    takes.push({
                        text: combinedText + ' ' + partialText,
                        duration: estimateDuration(combinedText + ' ' + partialText),
                        overlap: overlapText,
                        previousOverlap: null,
                        needsOverlap: true
                    });
                    
                    // Next take starts with the overlap
                    i = endIndex;
                    break;
                } else {
                    // Add the full sentence
                    combinedText += ' ' + nextSentence;
                    combinedDuration += nextDuration;
                    
                    // If we're now in good range, save it
                    if (combinedDuration >= minDuration) {
                        takes.push({
                            text: combinedText,
                            duration: combinedDuration,
                            overlap: null,
                            previousOverlap: null,
                            needsOverlap: false
                        });
                        i = endIndex + 1;
                        break;
                    }
                }
            }
            
            // If we've reached the end, add what we have
            if (endIndex === sentences.length - 1 && i <= endIndex) {
                takes.push({
                    text: combinedText,
                    duration: combinedDuration,
                    overlap: null,
                    previousOverlap: null,
                    needsOverlap: false
                });
                i = endIndex + 1;
            }
        }
        // If sentence is too long, we need to split it
        else {
            const words = sentence.split(/\s+/);
            const targetWords = Math.ceil(targetDuration * 2.5);
            const chunk = words.slice(0, targetWords).join(' ');
            
            // Create overlap
            const overlapWords = Math.ceil(overlapDuration * 2.5);
            const overlapText = words.slice(0, overlapWords).join(' ');
            
            takes.push({
                text: chunk,
                duration: estimateDuration(chunk),
                overlap: overlapText,
                previousOverlap: null,
                needsOverlap: true
            });
            
            // Put the rest back as a new sentence for next iteration
            const remainder = words.slice(targetWords).join(' ');
            sentences[i] = remainder;
            // Don't increment i, process the remainder next
        }
    }
    
    // Now process overlaps between takes
    for (let j = 1; j < takes.length; j++) {
        const prevTake = takes[j - 1];
        if (prevTake.needsOverlap && prevTake.overlap) {
            takes[j].previousOverlap = prevTake.overlap;
        }
    }
    
    // Render takes
    renderTakes(takes, fillerPrefix);
}
